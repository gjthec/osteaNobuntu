const fs = require("fs");
const path = require("path");

function exists(p){ try{ fs.accessSync(p); return true; } catch { return false; } }
function read(p){ return fs.readFileSync(p, "utf8"); }
function write(p, c){ fs.mkdirSync(path.dirname(p), {recursive:true}); fs.writeFileSync(p, c, "utf8"); }
function backup(p, stamp){
  if (!exists(p)) return;
  const out = path.join(".fix_backups", `${stamp}__${p.replace(/[\/\\]/g,"__")}`);
  fs.mkdirSync(path.dirname(out), {recursive:true});
  fs.copyFileSync(p, out);
}
function replaceInFile(file, regex, repl, stamp){
  if (!exists(file)) return false;
  const orig = read(file);
  const next = orig.replace(regex, repl);
  if (next !== orig){
    backup(file, stamp);
    write(file, next);
    return true;
  }
  return false;
}

const stamp = process.env.FIXSTAMP || new Date().toISOString().replace(/[:.]/g, "-");

// 1) Consertar src/utils/mongoose/customQuery.util.ts:
//    - remover re-export com ".ts"
//    - garantir export de FilterValue
const customQueryUtil = path.join("src","utils","mongoose","customQuery.util.ts");
const customQueryStub = `// AUTO-GENERATED by fix-tsc-v2.js
// Minimal typings to satisfy build. Replace with real implementation if needed.
export type FilterValue = any;

// You can add real helpers here if the project relies on them at runtime.
`;
backup(customQueryUtil, stamp);
write(customQueryUtil, customQueryStub);

// 2) Ajustar stub do DatabasePermissionRepository para aceitar args no constructor
const dbPermRepo = path.join("src","domain","repositories","databasePermission.repository.ts");
if (exists(dbPermRepo)){
  // se já é stub nosso, garante constructor(...args:any[])
  // se não for, tenta não destruir: só injeta constructor se for class sem constructor.
  const content = read(dbPermRepo);

  // Caso seja stub simples "export default class DatabasePermissionRepository { [key: string]: any; }"
  if (/export\s+default\s+class\s+DatabasePermissionRepository/.test(content)) {
    let next = content;

    // Se não tem constructor, adiciona
    if (!/constructor\s*\(/.test(next)) {
      next = next.replace(
        /export\s+default\s+class\s+DatabasePermissionRepository\s*\{\s*/m,
        match => match + "  constructor(..._args: any[]) {}\n"
      );
    }

    if (next !== content){
      backup(dbPermRepo, stamp);
      write(dbPermRepo, next);
    }
  }
}

// 3) registerTenantPermission.useCase.ts: cast pra destravar
const tenantPerm = path.join("src","useCases","tenant","registerTenantPermission.useCase.ts");

// 3a) tenantConnectionService.addPermission -> (tenantConnectionService as any).addPermission
replaceInFile(
  tenantPerm,
  /\btenantConnectionService\.addPermission\b/g,
  "(tenantConnectionService as any).addPermission",
  stamp
);

// 3b) return createdDatabasePermission; -> return createdDatabasePermission as DatabasePermission;
replaceInFile(
  tenantPerm,
  /return\s+createdDatabasePermission\s*;\s*$/m,
  "return createdDatabasePermission as DatabasePermission;",
  stamp
);

console.log("✅ v2 fixes aplicados. Backups em .fix_backups/", stamp);
